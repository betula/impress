
Представляю вашему вниманию библиотеку для организации отображения данных.
По сути это необходимо для организации приложения в архитектуре сервисов.


Библиотека для сервисной организации кода вашего приложения и связи данных с отображением. "@impress" позволяет оптимизировать учаски дерева необходимого для перерисовки.


Основные две задачи которые решает "@impress":
1. Организация логики вашего приложения в виде сервисов, представленных в виде классов ООП
2. Локализация областей вашего отображение для минимизации затрат на обновления

Т.е. "@impress" позволяет обновлять только те области приложения в которых содержаться изменившиеся данные. Нужно понимать, что "@impress" не является библиотекой для организации "Data Flow". Для этого вы можете использовать какой угодно способ, в пространстве библиотек "@impress" содержаться некоторые инструменты для организации "Data Flow", но вам нет никакой нужды их использовать если ваш выбор например RxJS, либо вы сами справляетесь с этой задачей собственным способом не прибегая в ограниченным коробочным решениям.

Внутренне библиотека дополнительных компонентов построена по принципы трейтов (inspired by Rust), потому вам не нужно использовать наследование или миксование в своей архитектуре, для подключения диспатчера или эвент эммитера например.

История:

Данная система возникла как синтез следующих технологий и наработок.

Система представленная командой Angular имеет на мой взгляд ряд отличных архитектурных решений, которые вдохновляли меня, а именно это архитектуру приложения представленную в виде сервисов (-особенно удобной для меня оказалась система представленная именно в первом поколении системы Angular-) и отсутствие какой-либо дополнительной обвязки для работы с данными, я просто присваивал данные в переменные и они тут же обновлялись на странице. Но если сервисы оказались чрезвычайно удобным и на мой взгляд отличным архитекрутрым решением, то вот насчет способа синхронизации данных с отображением я такого сказать не могу, при росте количества компонентов на странице производительность деградировалалсь пропорционально, причём для всей страницы, так как проверка всех изменившихся данных происходила на каждое пользователькое действие и абсолютно для всех отображенных элементов интерфейса, что увеличивало длительность саймой проверки (digest loop) не зависимо от того где именно произошли изменения. А второй притензией было организация Data Flow на этом же механизме через $watch, что не позволяло ясно видеть разницу и строить архитектуру так, что бы отдельно описывался механизм синхронизации состояния с отображением, а отдельно механизм Data Flow.



Сервисы в системе "@impress" представлены в виде классов не нужнающиеся в каком-либо родителе.




```TS
class User {
  @store name: string;
}

class UserNameEditor extends React.PureComponent {
  @provide user: User;

  render() {
    return (
      <input
        onChange={(e: any) => this.user.name = e.target.value}
        value={this.user.name}
      />
    )
  }
}
```
